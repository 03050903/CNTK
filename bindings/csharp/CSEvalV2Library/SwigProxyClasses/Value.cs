//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace CNTK {

public class Value : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  private bool swigCMemOwnBase;

  internal Value(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwnBase = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Value obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~Value() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwnBase) {
          swigCMemOwnBase = false;
          CNTKLibPINVOKE.delete_Value(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }


    public DeviceDescriptor Device
    {
        get
        {
            return GetDevice();
        }
    }

    public DataType DataType
    {
        get
        {
            return GetDataType();
        }
    }

    public StorageFormat StorgeFormat
    {
        get
        {
            return GetStorageFormat();
        }
    }

    public NDShape Shape
    {
        get
        {
            return GetShape();
        }
    }

    public bool IsSparse
    {
        get
        {
            return _IsSparse();
        }
    }

    public bool IsReadOnly
    {
        get
        {
            return _IsReadOnly();
        }
    }

    public int MaskedCount
    {
        get
        {
            return (int)_MaskedCount();
        }
    }

    // Create Value object from dense input: batch, sequence or batch of sequences.

    public static Value CreateBatch<T>(NDShape shape, System.Collections.Generic.List<T> batch, DeviceDescriptor computeDevice)
    {
        throw new System.ArgumentException("Not implemented yet.");
    }

    public static Value CreateSequence<T>(NDShape shape, System.Collections.Generic.List<T> sequence,
                                          bool seqStartFalg,
                                          DeviceDescriptor computeDevice)
    {
        throw new System.ArgumentException("Not implemented yet.");
    }

    public static Value CreateBatchOfSequences<T>(NDShape shape,
                                                  System.Collections.Generic.List<System.Collections.Generic.List<T>> batchOfSequences,
                                                  System.Collections.Generic.List<bool> seqStartFalg,
                                                  DeviceDescriptor computeDevice)
    {
        var dim = shape.TotalSize;

        // Todo: deal with seqStartFlag
        if (typeof(T).Equals(typeof(float)))
        {
            var inputSeqVector = new FloatVectorVector();
            foreach (var seq in batchOfSequences)
            {
                if (seq.Count % dim != 0)
                {
                    throw new System.ArgumentException("the number of data in sequences does not match the input dimension");
                }
                var samples = new FloatVector(seq);
                inputSeqVector.Add(samples);
            }
            return Value.CreateDenseFloat(shape, inputSeqVector, computeDevice);
        }
        else if (typeof(T).Equals(typeof(double)))
        {
            var inputSeqVector = new DoubleVectorVector();
            foreach (var seq in batchOfSequences)
            {
                if (seq.Count % dim != 0)
                {
                    throw new System.ArgumentException("the number of data in sequences does not match the input dimension");
                }
                var samples = new DoubleVector(seq);
                inputSeqVector.Add(samples);
            }
            return Value.CreateDenseDouble(shape, inputSeqVector, computeDevice);
        }
        else
        {
            throw new System.ArgumentException("The data type " + typeof(T).ToString() + " is not supported. Only float or double is supported by CNTK.");
        }
    }

    // Create Value object from OneHotVector input: batch, sequence or batch of sequences
    public static Value CreateBatch<T>(uint vacabSize, System.Collections.Generic.List<uint> batch, DeviceDescriptor computeDevice)
    {
        throw new System.ArgumentException("Not implemented yet.");
    }

    public static Value CreateSequence<T>(uint vacabSize,
                                          System.Collections.Generic.List<uint> sequence,
                                          bool seqStartFalg,
                                          DeviceDescriptor computeDevice)
    {
        throw new System.ArgumentException("Not implemented yet.");
    }

    public static Value CreateBatchOfSequences<T>(uint vacabSize, 
                                                  System.Collections.Generic.List<System.Collections.Generic.List<uint>> batchOfSequences,
                                                  System.Collections.Generic.List<bool> seqStartFalg,
                                                  DeviceDescriptor computeDevice)
    {
        throw new System.NotImplementedException("Not implemented");
    }

    // Create Value object from sparse input: batch, sequence or batch of sequences.
    public static Value CreateBatch<T>(NDShape shape, 
                                       System.Collections.Generic.List<T> data,
                                       System.Collections.Generic.List<uint> indexes,
                                       System.Collections.Generic.List<uint> nnzCounts,
                                       DeviceDescriptor computeDevice)
    {
        throw new System.ArgumentException("Not implemented yet.");
    }

    public static Value CreateSequence<T>(NDShape shape, 
                                          System.Collections.Generic.List<T> data,
                                          System.Collections.Generic.List<uint> indexes,
                                          System.Collections.Generic.List<uint> nnzCounts,
                                          bool SequenceStartFlag,
                                          DeviceDescriptor computeDevice)
    {
        throw new System.ArgumentException("Not implemented yet.");
    }

    // Create Value based on sparse input
    // Todo: could this be a extension to Value class??
    // Todo: use Variable instead of varName. VarName as extension method
    public static Value CreateBatchOfSequences<T>(NDShape shape,
                                                 System.Collections.Generic.List<System.Collections.Generic.List<T>> data,
                                                 System.Collections.Generic.List<System.Collections.Generic.List<uint>> indexes,
                                                 System.Collections.Generic.List<System.Collections.Generic.List<uint>> nnzCounts,
                                                 System.Collections.Generic.List<bool> SequenceStartFlag,
                                                 DeviceDescriptor computeDevice)
    {
        throw new System.NotImplementedException("Not implemented");
    }

  public Value(NDArrayView data) : this(CNTKLibPINVOKE.new_Value__SWIG_0(NDArrayView.getCPtr(data)), true) {
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public Value(NDArrayView data, NDMask mask) : this(CNTKLibPINVOKE.new_Value__SWIG_1(NDArrayView.getCPtr(data), NDMask.getCPtr(mask)), true) {
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public static Value Create(NDShape sampleShape, NDArrayViewVector sequences, BoolVector sequenceStartFlags, DeviceDescriptor device, bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Create__SWIG_4(NDShape.getCPtr(sampleShape), NDArrayViewVector.getCPtr(sequences), BoolVector.getCPtr(sequenceStartFlags), DeviceDescriptor.getCPtr(device), readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value Create(NDShape sampleShape, NDArrayViewVector sequences, BoolVector sequenceStartFlags, DeviceDescriptor device) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Create__SWIG_5(NDShape.getCPtr(sampleShape), NDArrayViewVector.getCPtr(sequences), BoolVector.getCPtr(sequenceStartFlags), DeviceDescriptor.getCPtr(device));
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value Create(NDShape sampleShape, NDArrayViewVector sequences, DeviceDescriptor device, bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Create__SWIG_6(NDShape.getCPtr(sampleShape), NDArrayViewVector.getCPtr(sequences), DeviceDescriptor.getCPtr(device), readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value Create(NDShape sampleShape, NDArrayViewVector sequences, DeviceDescriptor device) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Create__SWIG_7(NDShape.getCPtr(sampleShape), NDArrayViewVector.getCPtr(sequences), DeviceDescriptor.getCPtr(device));
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual DeviceDescriptor GetDevice() {
    DeviceDescriptor ret = new DeviceDescriptor(CNTKLibPINVOKE.Value_GetDevice(swigCPtr), true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual DataType GetDataType() {
    DataType ret = (DataType)CNTKLibPINVOKE.Value_GetDataType(swigCPtr);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual StorageFormat GetStorageFormat() {
    StorageFormat ret = (StorageFormat)CNTKLibPINVOKE.Value_GetStorageFormat(swigCPtr);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual NDShape GetShape() {
    NDShape ret = new NDShape(CNTKLibPINVOKE.Value_GetShape(swigCPtr), true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool _IsSparse() {
    bool ret = CNTKLibPINVOKE.Value__IsSparse(swigCPtr);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual bool _IsReadOnly() {
    bool ret = CNTKLibPINVOKE.Value__IsReadOnly(swigCPtr);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual uint _MaskedCount() {
    uint ret = CNTKLibPINVOKE.Value__MaskedCount(swigCPtr);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual NDArrayView Data() {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Data(swigCPtr);
    NDArrayView ret = (cPtr == global::System.IntPtr.Zero) ? null : new NDArrayView(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual NDMask Mask() {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Mask(swigCPtr);
    NDMask ret = (cPtr == global::System.IntPtr.Zero) ? null : new NDMask(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual Value DeepClone(bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_DeepClone__SWIG_0(swigCPtr, readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public Value DeepClone() {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_DeepClone__SWIG_1(swigCPtr);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual Value Alias(bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Alias__SWIG_0(swigCPtr, readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual Value Alias() {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_Alias__SWIG_1(swigCPtr);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual void CopyFrom(Value source) {
    CNTKLibPINVOKE.Value_CopyFrom(swigCPtr, Value.getCPtr(source));
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
  }

  public static Value CreateDenseFloat(NDShape sampleShape, FloatVectorVector sequences, DeviceDescriptor device, bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateDenseFloat__SWIG_0(NDShape.getCPtr(sampleShape), FloatVectorVector.getCPtr(sequences), DeviceDescriptor.getCPtr(device), readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value CreateDenseFloat(NDShape sampleShape, FloatVectorVector sequences, DeviceDescriptor device) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateDenseFloat__SWIG_1(NDShape.getCPtr(sampleShape), FloatVectorVector.getCPtr(sequences), DeviceDescriptor.getCPtr(device));
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value CreateDenseDouble(NDShape sampleShape, DoubleVectorVector sequences, DeviceDescriptor device, bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateDenseDouble__SWIG_0(NDShape.getCPtr(sampleShape), DoubleVectorVector.getCPtr(sequences), DeviceDescriptor.getCPtr(device), readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value CreateDenseDouble(NDShape sampleShape, DoubleVectorVector sequences, DeviceDescriptor device) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateDenseDouble__SWIG_1(NDShape.getCPtr(sampleShape), DoubleVectorVector.getCPtr(sequences), DeviceDescriptor.getCPtr(device));
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value CreateOneHotFloat(uint vocabularySize, SizeTVectorVector oneHotSequences, DeviceDescriptor device, bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateOneHotFloat__SWIG_0(vocabularySize, SizeTVectorVector.getCPtr(oneHotSequences), DeviceDescriptor.getCPtr(device), readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value CreateOneHotFloat(uint vocabularySize, SizeTVectorVector oneHotSequences, DeviceDescriptor device) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateOneHotFloat__SWIG_1(vocabularySize, SizeTVectorVector.getCPtr(oneHotSequences), DeviceDescriptor.getCPtr(device));
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value CreateOneHotDouble(uint vocabularySize, SizeTVectorVector oneHotSequences, DeviceDescriptor device, bool readOnly) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateOneHotDouble__SWIG_0(vocabularySize, SizeTVectorVector.getCPtr(oneHotSequences), DeviceDescriptor.getCPtr(device), readOnly);
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static Value CreateOneHotDouble(uint vocabularySize, SizeTVectorVector oneHotSequences, DeviceDescriptor device) {
    global::System.IntPtr cPtr = CNTKLibPINVOKE.Value_CreateOneHotDouble__SWIG_1(vocabularySize, SizeTVectorVector.getCPtr(oneHotSequences), DeviceDescriptor.getCPtr(device));
    Value ret = (cPtr == global::System.IntPtr.Zero) ? null : new Value(cPtr, true);
    if (CNTKLibPINVOKE.SWIGPendingException.Pending) throw CNTKLibPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

}

}
